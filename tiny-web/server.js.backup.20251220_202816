// Weekly_Grind unified server (no filesystem CSV storage)

// Load environment (DB credentials, SESSION_SECRET, etc.)
require('dotenv').config();

const path = require('path');
const express = require('express');
const session = require('express-session');
const bcrypt = require('bcrypt');
const fs = require('fs').promises;

const { pool, testDbConnection } = require('./db');

const app = express();
const PORT = process.env.PORT || 3000;

// -----------------------------------------------------------------------------
// Core middleware
// -----------------------------------------------------------------------------

app.use(express.json({ limit: '5mb' }));

app.use(
  session({
    secret: process.env.SESSION_SECRET || 'change-this-secret',
    resave: false,
    saveUninitialized: false,
    cookie: {
      httpOnly: true,
      sameSite: 'lax',
      maxAge: 1000 * 60 * 60 * 8, // 8 hours
    },
  })
);

// ===== DEV AUTH STUB REMOVED =====
// Real authentication now required - users must login via /auth/login
// Auth check happens automatically on each request via requireAuth middleware
// ===== END STUB SECTION =====

// -----------------------------------------------------------------------------
// Auth helpers (session + stub user)
// -----------------------------------------------------------------------------

function getCurrentUser(req) {
  return req.session?.user || req.user || null;
}

function requireAuth(req, res, next) {
  const user = getCurrentUser(req);
  if (!user) {
    return res.status(401).json({ error: 'Auth required' });
  }
  req.user = user;
  next();
}

function requireRole(...roles) {
  return (req, res, next) => {
    const user = getCurrentUser(req);
    if (!user) {
      return res.status(401).json({ error: 'Auth required' });
    }
    if (!roles.includes(user.role)) {
      return res.status(403).json({ error: 'Forbidden' });
    }
    req.user = user;
    next();
  };
}


// Require admin access
function requireAdmin(req, res, next) {
  const user = getCurrentUser(req);
  if (!user) {
    return res.status(401).json({ error: 'Auth required' });
  }
  if (!user.is_admin) {
    return res.status(403).json({ error: 'Admin access required' });
  }
  req.user = user;
  next();
}

// ============================================================================
// AUTO DATE CALCULATION FUNCTION
// ============================================================================

/**
 * Add business days to a date (excluding weekends)
 */
function addBusinessDays(date, days) {
  const result = new Date(date);
  let addedDays = 0;
  
  while (addedDays < days) {
    result.setDate(result.getDate() + 1);
    const dayOfWeek = result.getDay();
    // Skip weekends (0 = Sunday, 6 = Saturday)
    if (dayOfWeek !== 0 && dayOfWeek !== 6) {
      addedDays++;
    }
  }
  
  return result;
}

/**
 * Move date to next business day if it falls on weekend
 */
function nextBusinessDay(date) {
  const result = new Date(date);
  const dayOfWeek = result.getDay();
  
  if (dayOfWeek === 0) { // Sunday
    result.setDate(result.getDate() + 1); // Move to Monday
  } else if (dayOfWeek === 6) { // Saturday
    result.setDate(result.getDate() + 2); // Move to Monday
  }
  
  return result;
}

/**
 * Automatically calculates planned dates for all stages in a project
 * Respects hardware_received constraint for Deployment stage
 * Excludes weekends from calculations
 * Can be overridden by passing manual dates
 */
async function recalculateProjectStageDates(projectPid, manualOverrides = {}) {
  try {
    // Get project info
    const projectResult = await pool.query(
      'SELECT pid, date_project_opened, date_hardware_received FROM projects WHERE pid = $1',
      [projectPid]
    );

    if (projectResult.rows.length === 0) {
      throw new Error('Project not found');
    }

    const project = projectResult.rows[0];
    
    if (!project.date_project_opened) {
      console.log(`Project ${projectPid} has no date_project_opened, skipping date calculation`);
      return;
    }

    // Get all stages for this project, ordered by sort_order
    const stagesResult = await pool.query(`
      SELECT 
        ps.id,
        ps.project_pid,
        ps.stage_definition_id,
        ps.planned_duration_days,
        ps.assigned_tech_id,
        ps.planned_start_date,
        ps.planned_end_date,
        sd.sort_order,
        sd.display_name
      FROM project_stages ps
      JOIN stage_definitions sd ON ps.stage_definition_id = sd.id
      WHERE ps.project_pid = $1
      ORDER BY sd.sort_order
    `, [projectPid]);

    const stages = stagesResult.rows;
    
    if (stages.length === 0) {
      console.log(`No stages found for project ${projectPid}`);
      return;
    }

    // Calculate dates for each stage sequentially
    let previousEndDate = null;

    for (const stage of stages) {
      // Check if this stage has manual override
      const override = manualOverrides[stage.stage_definition_id];
      if (override && override.planned_start_date && override.planned_end_date) {
        // Use manual dates
        await pool.query(`
          UPDATE project_stages
          SET 
            planned_start_date = $1,
            planned_end_date = $2,
            updated_at = NOW()
          WHERE id = $3
        `, [override.planned_start_date, override.planned_end_date, stage.id]);

        console.log(`${stage.display_name}: Manual override ${override.planned_start_date} â†’ ${override.planned_end_date}`);
        previousEndDate = new Date(override.planned_end_date + 'T00:00:00');
        continue;
      }

      // Only calculate if tech is assigned
      if (!stage.assigned_tech_id) {
        console.log(`Stage ${stage.display_name} has no tech assigned, skipping auto-calc`);
        continue;
      }

      const duration = stage.planned_duration_days || 7;
      let startDate, endDate;

      if (stage.sort_order === 1) {
        // Stage 1: Start on date_project_opened (or next business day)
        startDate = new Date(project.date_project_opened + 'T00:00:00');
        startDate = nextBusinessDay(startDate);
        endDate = addBusinessDays(startDate, duration - 1);

      } else if (stage.sort_order === 2) {
        // Stage 2: Start NEXT BUSINESS DAY after Stage 1 ends (NO GAP)
        if (!previousEndDate) {
          console.log(`Stage 2 cannot start: Stage 1 has no end date`);
          continue;
        }
        startDate = addBusinessDays(previousEndDate, 1); // Next business day after previous ends
        endDate = addBusinessDays(startDate, duration - 1);

      } else if (stage.sort_order === 3) {
        // Stage 3 (Deployment): Start the LATER of:
        //   1. Next business day after Stage 2 ends
        //   2. Next business day after hardware_received
        if (!previousEndDate) {
          console.log(`Stage 3 cannot start: Stage 2 has no end date`);
          continue;
        }

        // Calculate next business day after Testing ends
        const afterTesting = addBusinessDays(previousEndDate, 1);

        // Calculate next business day after hardware received (if set)
        let afterHardware = afterTesting; // Default to afterTesting
        if (project.date_hardware_received) {
          afterHardware = new Date(project.date_hardware_received + 'T00:00:00');
          afterHardware = nextBusinessDay(afterHardware);
          afterHardware = addBusinessDays(afterHardware, 1);
        }

        // Use the LATER date
        startDate = afterTesting > afterHardware ? afterTesting : afterHardware;
        endDate = addBusinessDays(startDate, duration - 1);
      }

      // Format dates as YYYY-MM-DD
      const startDateStr = startDate.toISOString().split('T')[0];
      const endDateStr = endDate.toISOString().split('T')[0];

      // Update the database
      await pool.query(`
        UPDATE project_stages
        SET 
          planned_start_date = $1,
          planned_end_date = $2,
          updated_at = NOW()
        WHERE id = $3
      `, [startDateStr, endDateStr, stage.id]);

      console.log(`${stage.display_name}: ${startDateStr} â†’ ${endDateStr} (${duration} business days)`);

      // Store for next stage
      previousEndDate = endDate;
    }

    console.log(`âœ“ Recalculated dates for project ${projectPid}`);

  } catch (err) {
    console.error(`Error recalculating dates for project ${projectPid}:`, err);
    throw err;
  }
}

// ============================================================================
// END AUTO DATE CALCULATION
// ============================================================================

// -----------------------------------------------------------------------------
// AUTH & USER ROUTES
// -----------------------------------------------------------------------------

// Login endpoint
app.post('/auth/login', async (req, res) => {
  try {
    console.log('Login attempt for:', req.body.username);
    
    const { username, password } = req.body;

    if (!username || !password) {
      console.log('Missing username or password');
      return res.status(400).json({ error: 'Username and password required' });
    }

    // Check if pool is initialized
    if (!pool) {
      console.error('Database pool not initialized!');
      return res.status(500).json({ error: 'Database connection error' });
    }

    // Try to get user with avatar, but handle if column doesn't exist
    let result;
    try {
      console.log('Querying database for user...');
      result = await pool.query(
        'SELECT id, username, password, display_name, email, role, is_admin, avatar FROM users WHERE username = $1',
        [username]
      );
      console.log('Query result rows:', result.rows.length);
    } catch (err) {
      console.log('Avatar column error, trying without:', err.message);
      // If avatar column doesn't exist, try without it
      if (err.message.includes('avatar') || err.message.includes('column') || err.message.includes('does not exist')) {
        try {
          result = await pool.query(
            'SELECT id, username, password, display_name, email, role, is_admin FROM users WHERE username = $1',
            [username]
          );
          console.log('Query without avatar successful, rows:', result.rows.length);
        } catch (err2) {
          console.error('Database query failed:', err2);
          throw err2;
        }
      } else {
        console.error('Database query error:', err);
        throw err;
      }
    }

    if (!result || result.rows.length === 0) {
      console.log('User not found:', username);
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const user = result.rows[0];
    console.log('User found:', user.username, 'Role:', user.role);
    
    if (!user.password) {
      console.error('User has no password in database!');
      return res.status(500).json({ error: 'Invalid user data' });
    }

    const passwordMatch = await bcrypt.compare(password, user.password);
    console.log('Password match:', passwordMatch);

    if (!passwordMatch) {
      console.log('Invalid password for user:', username);
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Store user in session (excluding password)
    req.session.user = {
      id: user.id,
      username: user.username,
      display_name: user.display_name || user.username,
      email: user.email || '',
      role: user.role || 'tech',
      is_admin: user.is_admin || false,
      avatar: user.avatar || 'ðŸ‘¤'
    };

    console.log('Login successful for:', username);

    return res.json({
      id: user.id,
      username: user.username,
      display_name: user.display_name || user.username,
      email: user.email || '',
      role: user.role || 'tech',
      is_admin: user.is_admin || false,
      avatar: user.avatar || 'ðŸ‘¤',
      redirectUrl: (() => {
        if (user.role === 'tech') return '/weekly-grind/view';
        if (user.role === 'coordinator') return '/weekly-grind/projects';
        if (user.role === 'supervisor') return '/weekly-grind/supervisor-dashboard';
        if (user.role === 'manager') return '/weekly-grind/manager-dashboard';
        if (user.is_admin) return '/weekly-grind/admin-options';
        return '/weekly-grind/view';
      })()
    });
  } catch (err) {
    console.error('Login error details:', err);
    console.error('Error stack:', err.stack);
    return res.status(500).json({ 
      error: 'Login failed', 
      details: process.env.NODE_ENV === 'development' ? err.message : undefined 
    });
  }
});

// Logout endpoint
app.post('/auth/logout', (req, res) => {
  req.session.destroy(err => {
    if (err) {
      console.error('Logout error:', err);
      return res.status(500).json({ error: 'Logout failed' });
    }
    res.json({ success: true });
  });
});

// Get current user
app.get('/auth/me', requireAuth, (req, res) => {
  res.json(req.user);
});

// Update user avatar
app.post('/auth/update-avatar', requireAuth, async (req, res) => {
  try {
    const { avatar } = req.body;
    
    if (!avatar) {
      return res.status(400).json({ error: 'Avatar required' });
    }

    await pool.query(
      'UPDATE users SET avatar = $1 WHERE id = $2',
      [avatar, req.user.id]
    );

    // Update session
    req.session.user.avatar = avatar;

    res.json({ success: true, avatar });
  } catch (err) {
    console.error('Error updating avatar:', err);
    res.status(500).json({ error: 'Failed to update avatar' });
  }
});

// Change own password
app.post('/auth/change-password', requireAuth, async (req, res) => {
  try {
    const { currentPassword, newPassword } = req.body;

    if (!currentPassword || !newPassword) {
      return res.status(400).json({ error: 'Current and new password required' });
    }

    // Get user with current password
    const result = await pool.query(
      'SELECT password FROM users WHERE id = $1',
      [req.user.id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Verify current password
    const passwordMatch = await bcrypt.compare(currentPassword, result.rows[0].password);
    
    if (!passwordMatch) {
      return res.status(401).json({ error: 'Current password is incorrect' });
    }

    // Hash new password
    const hashedPassword = await bcrypt.hash(newPassword, 10);

    // Update password
    await pool.query(
      'UPDATE users SET password = $1 WHERE id = $2',
      [hashedPassword, req.user.id]
    );

    res.json({ success: true });
  } catch (err) {
    console.error('Error changing password:', err);
    res.status(500).json({ error: 'Failed to change password' });
  }
});

// ============================================================================
// NEW: ADMIN PASSWORD RESET & ACTION LOGGING
// ============================================================================

// Reset user password (admin only) - /api/users/:id/reset-password endpoint
app.post('/api/users/:id/reset-password', requireAdmin, async (req, res) => {
  try {
    const userId = parseInt(req.params.id);
    const defaultPassword = 'TempPass123!';
    
    // Hash the default password
    const hashedPassword = await bcrypt.hash(defaultPassword, 10);
    
    // Update user's password in database
    const result = await pool.query(
      'UPDATE users SET password = $1 WHERE id = $2 RETURNING username',
      [hashedPassword, userId]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).send('User not found');
    }
    
    console.log(`Password reset for user ${result.rows[0].username} by ${req.user.username}`);
    res.json({ success: true, username: result.rows[0].username });
    
  } catch (error) {
    console.error('Error resetting password:', error);
    res.status(500).send('Error resetting password');
  }
});

// Reset user password (admin only) - /auth/users/:id/reset-password endpoint (alias)
app.post('/auth/users/:id/reset-password', requireAdmin, async (req, res) => {
  try {
    const userId = parseInt(req.params.id);
    const defaultPassword = 'TempPass123!';
    
    // Hash the default password
    const hashedPassword = await bcrypt.hash(defaultPassword, 10);
    
    // Update user's password in database
    const result = await pool.query(
      'UPDATE users SET password = $1 WHERE id = $2 RETURNING username',
      [hashedPassword, userId]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).send('User not found');
    }
    
    console.log(`Password reset for user ${result.rows[0].username} by ${req.user.username}`);
    res.json({ success: true, username: result.rows[0].username });
    
  } catch (error) {
    console.error('Error resetting password:', error);
    res.status(500).send('Error resetting password');
  }
});

// Log admin actions
app.post('/auth/log-action', requireAuth, async (req, res) => {
  try {
    const { action, target_user, target_user_id, timestamp } = req.body;
    const admin_user = req.user.username;
    const admin_user_id = req.user.id;
    
    // Create log entry
    const logEntry = {
      timestamp: timestamp || new Date().toISOString(),
      admin_user,
      admin_user_id,
      action,
      target_user,
      target_user_id,
      ip_address: req.ip
    };
    
    // Log to database
    await pool.query(
      `INSERT INTO admin_action_logs 
       (admin_user_id, admin_username, action, target_user_id, target_username, ip_address, timestamp) 
       VALUES ($1, $2, $3, $4, $5, $6, $7)`,
      [admin_user_id, admin_user, action, target_user_id, target_user, req.ip, timestamp]
    );
    
    // Also log to file as backup
    const logDir = path.join(__dirname, 'logs');
    const logFile = path.join(logDir, 'admin-actions.log');
    
    // Ensure log directory exists
    try {
      await fs.mkdir(logDir, { recursive: true });
    } catch (err) {
      // Directory might already exist
    }
    
    // Append to log file
    const logLine = JSON.stringify(logEntry) + '\n';
    await fs.appendFile(logFile, logLine);
    
    console.log('Admin action logged:', logEntry);
    res.json({ success: true });
    
  } catch (error) {
    console.error('Error logging action:', error);
    res.status(500).send('Error logging action');
  }
});

// View action logs (admin only)
app.get('/auth/action-logs', requireAdmin, async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 100;
    const offset = parseInt(req.query.offset) || 0;
    
    const result = await pool.query(
      `SELECT * FROM admin_action_logs 
       ORDER BY timestamp DESC 
       LIMIT $1 OFFSET $2`,
      [limit, offset]
    );
    
    res.json(result.rows);
    
  } catch (error) {
    console.error('Error fetching action logs:', error);
    res.status(500).send('Error fetching logs');
  }
});

// ============================================================================
// END ADMIN PASSWORD RESET & ACTION LOGGING
// ============================================================================

// Get all users (admin only) - /api/users endpoint
app.get('/api/users', requireAdmin, async (req, res) => {
  try {
    // Check if filtering for assignment (scheduling page)
    const forAssignment = req.query.for_assignment === 'true';
    
    let query = `
      SELECT 
        id,
        username,
        display_name,
        email,
        role,
        is_active,
        is_admin,
        created_at,
        avatar
      FROM users
    `;
    
    // Filter to techs only for scheduling
    if (forAssignment) {
      query += ` WHERE role = 'tech' AND (is_active = true OR active = true)`;
    }
    
    query += ` ORDER BY username`;
    
    const result = await pool.query(query);
    
    res.json(result.rows);
  } catch (err) {
    console.error('Error fetching users:', err);
    res.status(500).json({ error: 'Failed to fetch users' });
  }
});

// Get all users (admin only) - /auth/users endpoint (alias)
app.get('/auth/users', requireAdmin, async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT 
        id,
        username,
        display_name,
        email,
        role,
        is_active,
        is_admin,
        created_at,
        avatar
      FROM users
      ORDER BY username
    `);
    
    res.json(result.rows);
  } catch (err) {
    console.error('Error fetching users:', err);
    res.status(500).json({ error: 'Failed to fetch users' });
  }
});

// Create new user (admin only) - /api/users endpoint
app.post('/api/users', requireAdmin, async (req, res) => {
  try {
    const { username, display_name, email, password, role } = req.body;

    if (!username || !password) {
      return res.status(400).json({ error: 'Username and password required' });
    }

    // Check if username already exists
    const existing = await pool.query(
      'SELECT id FROM users WHERE username = $1',
      [username]
    );

    if (existing.rows.length > 0) {
      return res.status(400).json({ error: 'Username already exists' });
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create user
    const result = await pool.query(
      `INSERT INTO users (username, display_name, email, password, role)
       VALUES ($1, $2, $3, $4, $5)
       RETURNING id, username, display_name, email, role, is_active, is_admin, created_at, avatar`,
      [username, display_name, email, hashedPassword, role || 'tech']
    );

    res.json(result.rows[0]);
  } catch (err) {
    console.error('Error creating user:', err);
    res.status(500).json({ error: 'Failed to create user' });
  }
});

// Create new user (admin only) - /auth/users endpoint (alias)
app.post('/auth/users', requireAdmin, async (req, res) => {
  try {
    const { username, display_name, email, password, role } = req.body;

    if (!username || !password) {
      return res.status(400).json({ error: 'Username and password required' });
    }

    // Check if username already exists
    const existing = await pool.query(
      'SELECT id FROM users WHERE username = $1',
      [username]
    );

    if (existing.rows.length > 0) {
      return res.status(400).json({ error: 'Username already exists' });
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create user
    const result = await pool.query(
      `INSERT INTO users (username, display_name, email, password, role)
       VALUES ($1, $2, $3, $4, $5)
       RETURNING id, username, display_name, email, role, is_active, is_admin, created_at, avatar`,
      [username, display_name, email, hashedPassword, role || 'tech']
    );

    res.json(result.rows[0]);
  } catch (err) {
    console.error('Error creating user:', err);
    res.status(500).json({ error: 'Failed to create user' });
  }
});

// Update user (admin only) - /api/users/:id endpoint
app.put('/api/users/:id', requireAdmin, async (req, res) => {
  try {
    const userId = parseInt(req.params.id);
    const { username, display_name, email, role, supervisor_id, manager_id } = req.body;

    const result = await pool.query(
      `UPDATE users
       SET username = $1, display_name = $2, email = $3, role = $4, 
           supervisor_id = $5, manager_id = $6
       WHERE id = $7
       RETURNING id, username, display_name, email, role, supervisor_id, manager_id, created_at, avatar`,
      [username, display_name, email, role, supervisor_id || null, manager_id || null, userId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.json(result.rows[0]);
  } catch (err) {
    console.error('Error updating user:', err);
    res.status(500).json({ error: 'Failed to update user' });
  }
});

// Update user (admin only) - /auth/users/:id endpoint (alias)
app.put('/auth/users/:id', requireAdmin, async (req, res) => {
  try {
    const userId = parseInt(req.params.id);
    const { username, display_name, email, role, supervisor_id, manager_id } = req.body;

    const result = await pool.query(
      `UPDATE users
       SET username = $1, display_name = $2, email = $3, role = $4, 
           supervisor_id = $5, manager_id = $6
       WHERE id = $7
       RETURNING id, username, display_name, email, role, supervisor_id, manager_id, created_at, avatar`,
      [username, display_name, email, role, supervisor_id || null, manager_id || null, userId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.json(result.rows[0]);
  } catch (err) {
    console.error('Error updating user:', err);
    res.status(500).json({ error: 'Failed to update user' });
  }
});

// Delete user (admin only) - /api/users/:id endpoint
app.delete('/api/users/:id', requireAdmin, async (req, res) => {
  try {
    const userId = parseInt(req.params.id);

    // Don't allow deleting yourself
    if (userId === req.user.id) {
      return res.status(400).json({ error: 'Cannot delete your own account' });
    }

    const result = await pool.query(
      'DELETE FROM users WHERE id = $1',
      [userId]
    );

    if (result.rowCount === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.json({ success: true });
  } catch (err) {
    console.error('Error deleting user:', err);
    res.status(500).json({ error: 'Failed to delete user' });
  }
});

// Delete user (admin only) - /auth/users/:id endpoint (alias)
app.delete('/auth/users/:id', requireAdmin, async (req, res) => {
  try {
    const userId = parseInt(req.params.id);

    // Don't allow deleting yourself
    if (userId === req.user.id) {
      return res.status(400).json({ error: 'Cannot delete your own account' });
    }

    const result = await pool.query(
      'DELETE FROM users WHERE id = $1',
      [userId]
    );

    if (result.rowCount === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.json({ success: true });
  } catch (err) {
    console.error('Error deleting user:', err);
    res.status(500).json({ error: 'Failed to delete user' });
  }
});

// Get supervisor-tech relationships
app.get('/auth/supervisor-techs', requireAdmin, async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT 
        u.id as user_id,
        u.username,
        u.display_name,
        u.role,
        u.supervisor_id,
        s.username as supervisor_username,
        s.display_name as supervisor_display_name
      FROM users u
      LEFT JOIN users s ON u.supervisor_id = s.id
      WHERE u.role IN ('tech', 'coordinator')
      ORDER BY u.username
    `);
    
    res.json(result.rows);
  } catch (err) {
    console.error('Error fetching supervisor-techs:', err);
    res.status(500).json({ error: 'Failed to fetch relationships' });
  }
});

// Update supervisor-tech relationships
app.post('/auth/supervisor-techs', requireAdmin, async (req, res) => {
  try {
    const { supervisor_id, tech_ids } = req.body;

    // First, clear existing relationships for this supervisor
    await pool.query(
      'UPDATE users SET supervisor_id = NULL WHERE supervisor_id = $1 AND role IN ($2, $3)',
      [supervisor_id, 'tech', 'coordinator']
    );

    // Then set new relationships
    if (tech_ids && tech_ids.length > 0) {
      for (const techId of tech_ids) {
        await pool.query(
          'UPDATE users SET supervisor_id = $1 WHERE id = $2',
          [supervisor_id, techId]
        );
      }
    }

    res.json({ success: true });
  } catch (err) {
    console.error('Error updating supervisor-techs:', err);
    res.status(500).json({ error: 'Failed to update relationships' });
  }
});

// Get manager-supervisor relationships
app.get('/auth/manager-supervisors', requireAdmin, async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT 
        u.id as user_id,
        u.username,
        u.display_name,
        u.role,
        u.manager_id,
        m.username as manager_username,
        m.display_name as manager_display_name
      FROM users u
      LEFT JOIN users m ON u.manager_id = m.id
      WHERE u.role = 'supervisor'
      ORDER BY u.username
    `);
    
    res.json(result.rows);
  } catch (err) {
    console.error('Error fetching manager-supervisors:', err);
    res.status(500).json({ error: 'Failed to fetch relationships' });
  }
});

// Update manager-supervisor relationships
app.post('/auth/manager-supervisors', requireAdmin, async (req, res) => {
  try {
    const { manager_id, supervisor_ids } = req.body;

    // First, clear existing relationships for this manager
    await pool.query(
      'UPDATE users SET manager_id = NULL WHERE manager_id = $1 AND role = $2',
      [manager_id, 'supervisor']
    );

    // Then set new relationships
    if (supervisor_ids && supervisor_ids.length > 0) {
      for (const superId of supervisor_ids) {
        await pool.query(
          'UPDATE users SET manager_id = $1 WHERE id = $2',
          [manager_id, superId]
        );
      }
    }

    res.json({ success: true });
  } catch (err) {
    console.error('Error updating manager-supervisors:', err);
    res.status(500).json({ error: 'Failed to update relationships' });
  }
});

// -----------------------------------------------------------------------------
// INITIATIVES API
// -----------------------------------------------------------------------------

// Get all initiatives
app.get('/api/initiatives', requireAuth, async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT 
        i.*,
        u.display_name as created_by_name
      FROM initiatives i
      LEFT JOIN users u ON i.created_by_user_id = u.id
      ORDER BY i.created_at DESC
    `);
    
    res.json(result.rows);
  } catch (err) {
    console.error('Error fetching initiatives:', err);
    res.status(500).json({ error: 'Failed to fetch initiatives' });
  }
});

// Create initiative
app.post('/api/initiatives', requireAuth, async (req, res) => {
  try {
    const { title, description, priority, status } = req.body;

    const result = await pool.query(
      `INSERT INTO initiatives (title, description, priority, status, created_by_user_id)
       VALUES ($1, $2, $3, $4, $5)
       RETURNING *`,
      [title, description, priority || 'medium', status || 'proposed', req.user.id]
    );

    res.json(result.rows[0]);
  } catch (err) {
    console.error('Error creating initiative:', err);
    res.status(500).json({ error: 'Failed to create initiative' });
  }
});

// Update initiative
app.put('/api/initiatives/:id', requireAuth, async (req, res) => {
  try {
    const { id } = req.params;
    const { title, description, priority, status } = req.body;

    const result = await pool.query(
      `UPDATE initiatives
       SET title = $1, description = $2, priority = $3, status = $4, updated_at = NOW()
       WHERE id = $5
       RETURNING *`,
      [title, description, priority, status, id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Initiative not found' });
    }

    res.json(result.rows[0]);
  } catch (err) {
    console.error('Error updating initiative:', err);
    res.status(500).json({ error: 'Failed to update initiative' });
  }
});

// Delete initiative
app.delete('/api/initiatives/:id', requireRole('admin', 'manager'), async (req, res) => {
  try {
    const { id } = req.params;

    const result = await pool.query(
      'DELETE FROM initiatives WHERE id = $1',
      [id]
    );

    if (result.rowCount === 0) {
      return res.status(404).json({ error: 'Initiative not found' });
    }

    res.json({ success: true });
  } catch (err) {
    console.error('Error deleting initiative:', err);
    res.status(500).json({ error: 'Failed to delete initiative' });
  }
});

// -----------------------------------------------------------------------------
// PROJECTS API
// -----------------------------------------------------------------------------

// Get all projects
// ============================================================================
// REPAIR & REIMAGE API
// ============================================================================

app.get('/api/repair-reimage', requireAuth, async (req, res) => {
  try {
    const { status, client_id, sort_by, sort_order } = req.query;
    
    let query = `SELECT r.*, u.display_name as assigned_tech_name, c.display_name as created_by_name
                 FROM repair_reimage r
                 LEFT JOIN users u ON r.assigned_tech_id = u.id
                 LEFT JOIN users c ON r.created_by = c.id WHERE 1=1`;
    const params = [];
    let pc = 1;
    
    if (status) {
      query += ` AND r.status = $${pc++}`;
      params.push(status);
    }
    if (client_id) {
      query += ` AND r.client_id ILIKE $${pc++}`;
      params.push(`%${client_id}%`);
    }
    
    const sortCol = ['date_received','stp_case_number','status','unit_name'].includes(sort_by) ? sort_by : 'date_received';
    query += ` ORDER BY r.${sortCol} ${sort_order === 'asc' ? 'ASC' : 'DESC'}`;
    
    const result = await pool.query(query, params);
    res.json(result.rows);
  } catch (err) {
    console.error('Error fetching repair items:', err);
    res.status(500).json({ error: 'Failed to fetch items' });
  }
});

app.post('/api/repair-reimage', requireRole('supervisor', 'manager', 'coordinator', 'admin'), async (req, res) => {
  try {
    const { stp_case_number, mfg_case_number, unit_name, client_id, status, date_received, 
            manufacturer, serial_number, notes, assigned_tech_id } = req.body;
    const user = getCurrentUser(req);
    
    const result = await pool.query(
      `INSERT INTO repair_reimage (stp_case_number, mfg_case_number, unit_name, client_id,
       status, date_received, manufacturer, serial_number, notes, assigned_tech_id, created_by)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) RETURNING *`,
      [stp_case_number, mfg_case_number, unit_name, client_id, status || 'Received',
       date_received || new Date().toISOString().split('T')[0], manufacturer, serial_number,
       notes, assigned_tech_id, user.id]
    );
    res.status(201).json(result.rows[0]);
  } catch (err) {
    console.error('Error creating repair item:', err);
    res.status(500).json({ error: 'Failed to create item' });
  }
});

app.put('/api/repair-reimage/:id', requireRole('supervisor', 'manager', 'coordinator', 'admin'), async (req, res) => {
  try {
    const { id } = req.params;
    const { stp_case_number, mfg_case_number, unit_name, client_id, status, date_received,
            manufacturer, serial_number, notes, assigned_tech_id } = req.body;
    
    const result = await pool.query(
      `UPDATE repair_reimage SET stp_case_number=$1, mfg_case_number=$2, unit_name=$3,
       client_id=$4, status=$5, date_received=$6, manufacturer=$7, serial_number=$8,
       notes=$9, assigned_tech_id=$10, updated_at=NOW() WHERE id=$11 RETURNING *`,
      [stp_case_number, mfg_case_number, unit_name, client_id, status, date_received,
       manufacturer, serial_number, notes, assigned_tech_id, id]
    );
    
    if (result.rows.length === 0) return res.status(404).json({ error: 'Not found' });
    res.json(result.rows[0]);
  } catch (err) {
    console.error('Error updating repair item:', err);
    res.status(500).json({ error: 'Failed to update item' });
  }
});

app.delete('/api/repair-reimage/:id', requireAdmin, async (req, res) => {
  try {
    const result = await pool.query('DELETE FROM repair_reimage WHERE id=$1 RETURNING *', [req.params.id]);
    if (result.rows.length === 0) return res.status(404).json({ error: 'Not found' });
    res.json({ success: true });
  } catch (err) {
    console.error('Error deleting repair item:', err);
    res.status(500).json({ error: 'Failed to delete item' });
  }
});

// ============================================================================
// USER RELATIONS API
// ============================================================================

app.get('/api/user-relations', requireAuth, async (req, res) => {
  try {
    const usersResult = await pool.query('SELECT id, username, display_name, email, role, is_active, is_admin, avatar FROM users ORDER BY display_name');
    const supervisorTechsResult = await pool.query('SELECT supervisor_id, tech_id FROM supervisor_techs');
    const managerSupervisorsResult = await pool.query('SELECT manager_id, supervisor_id FROM manager_supervisors');
    
    res.json({
      users: usersResult.rows,
      supervisorTechs: supervisorTechsResult.rows,
      managerSupervisors: managerSupervisorsResult.rows
    });
  } catch (err) {
    console.error('Error fetching user relations:', err);
    res.status(500).json({ error: 'Failed to fetch relations' });
  }
});


// ============================================================================
// SUPERVISOR-TECHS & MANAGER-SUPERVISORS API
// ============================================================================

// Update supervisor-techs relationships
app.post('/api/supervisor-techs/:supervisorId', requireAdmin, async (req, res) => {
  try {
    const { supervisorId } = req.params;
    const { techIds } = req.body; // Array of tech IDs
    
    await pool.query('BEGIN');
    
    // Delete existing relationships for this supervisor
    await pool.query('DELETE FROM supervisor_techs WHERE supervisor_id = $1', [supervisorId]);
    
    // Insert new relationships
    if (techIds && techIds.length > 0) {
      for (const techId of techIds) {
        await pool.query(
          'INSERT INTO supervisor_techs (supervisor_id, tech_id) VALUES ($1, $2)',
          [supervisorId, techId]
        );
      }
    }
    
    await pool.query('COMMIT');
    res.json({ success: true });
  } catch (err) {
    await pool.query('ROLLBACK');
    console.error('Error updating supervisor-techs:', err);
    res.status(500).json({ error: 'Failed to update relationships' });
  }
});

// Update manager-supervisors relationships
app.post('/api/manager-supervisors/:managerId', requireAdmin, async (req, res) => {
  try {
    const { managerId } = req.params;
    const { supervisorIds } = req.body; // Array of supervisor IDs
    
    await pool.query('BEGIN');
    
    // Delete existing relationships for this manager
    await pool.query('DELETE FROM manager_supervisors WHERE manager_id = $1', [managerId]);
    
    // Insert new relationships
    if (supervisorIds && supervisorIds.length > 0) {
      for (const supervisorId of supervisorIds) {
        await pool.query(
          'INSERT INTO manager_supervisors (manager_id, supervisor_id) VALUES ($1, $2)',
          [managerId, supervisorId]
        );
      }
    }
    
    await pool.query('COMMIT');
    res.json({ success: true });
  } catch (err) {
    await pool.query('ROLLBACK');
    console.error('Error updating manager-supervisors:', err);
    res.status(500).json({ error: 'Failed to update relationships' });
  }
});

// ============================================================================
// PROJECTS API
// ============================================================================

app.get('/api/projects', requireAuth, async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT 
        p.*,
        u.display_name as assigned_tech_name,
        CURRENT_DATE - p.date_project_opened as days_open,
        CURRENT_DATE - p.date_last_contacted as days_since_comms
      FROM projects p
      LEFT JOIN users u ON p.assigned_tech_id = u.id
      ORDER BY p.date_project_opened DESC, p.pid DESC
    `);
    
    res.json(result.rows);
  } catch (err) {
    console.error('Error fetching projects:', err);
    res.status(500).json({ error: 'Failed to fetch projects' });
  }
});


// Get single project
app.get('/api/projects/:pid', requireAuth, async (req, res) => {
  try {
    const { pid } = req.params;
    
    const result = await pool.query(`
      SELECT 
        p.*,
        u.display_name as assigned_tech_name,
        CURRENT_DATE - p.date_project_opened as days_open,
        CURRENT_DATE - p.date_last_contacted as days_since_comms
      FROM projects p
      LEFT JOIN users u ON p.assigned_tech_id = u.id
      WHERE p.pid = $1
    `, [pid]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Project not found' });
    }
    
    res.json(result.rows[0]);
  } catch (err) {
    console.error('Error fetching project:', err);
    res.status(500).json({ error: 'Failed to fetch project' });
  }
});


// Create new project with stages
app.post('/api/projects', requireRole('coordinator', 'supervisor', 'manager'), async (req, res) => {
  try {
    const {
      pid, client_id, project_name, description,
      num_desktops, num_laptops, num_images,
      onsite_or_ship, onsite_scheduled, onsite_date,
      date_project_opened, date_hardware_received, hardware_eta,
      date_last_contacted, contact_method, customer_temp,
      status, notes, bypass
    } = req.body;

    const result = await pool.query(
      `INSERT INTO projects (
        pid, client_id, project_name, description,
        num_desktops, num_laptops, num_images,
        onsite_or_ship, onsite_scheduled, onsite_date,
        date_project_opened, date_hardware_received, hardware_eta,
        date_last_contacted, contact_method, customer_temp,
        status, notes, bypass
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)
      RETURNING *`,
      [
        pid, client_id, project_name, description,
        num_desktops, num_laptops, num_images,
        onsite_or_ship, onsite_scheduled, onsite_date,
        date_project_opened, date_hardware_received, hardware_eta,
        date_last_contacted, contact_method, customer_temp,
        status || 'open', notes, bypass || false
      ]
    );
    
    res.status(201).json(result.rows[0]);
  } catch (err) {
    console.error('Error creating project:', err);
    res.status(500).json({ error: 'Failed to create project' });
  }
});

// Update project
app.put('/api/projects/:pid', requireRole('admin', 'supervisor', 'manager'), async (req, res) => {
  try {
    const { pid } = req.params;
    const {
      customer_id,
      date_project_opened,
      date_hardware_received,
      notes,
      stages
    } = req.body;

    await pool.query('BEGIN');

    // Update project
    const projectResult = await pool.query(
      `UPDATE projects
       SET customer_id = $1, 
           date_project_opened = $2, 
           date_hardware_received = $3,
           notes = $4,
           updated_at = NOW()
       WHERE pid = $5
       RETURNING *`,
      [customer_id, date_project_opened, date_hardware_received || null, notes || null, pid]
    );

    if (projectResult.rows.length === 0) {
      await pool.query('ROLLBACK');
      return res.status(404).json({ error: 'Project not found' });
    }

    const user = getCurrentUser(req);

    // Log project update
    await pool.query(
      `INSERT INTO audit_log (user_id, action, entity_type, entity_id, details)
       VALUES ($1, $2, $3, $4, $5)`,
      [
        user.id,
        'update',
        'project',
        pid,
        JSON.stringify({
          updated_by: user.username,
          changes: { customer_id, date_project_opened, date_hardware_received, notes }
        })
      ]
    );

    // Update stages if provided
    if (stages && stages.length > 0) {
      for (const stage of stages) {
        if (stage.id) {
          // Update existing stage
          await pool.query(
            `UPDATE project_stages
             SET assigned_tech_id = $1,
                 planned_duration_days = $2,
                 updated_at = NOW()
             WHERE id = $3 AND project_pid = $4`,
            [stage.assigned_tech_id || null, stage.planned_duration_days || 7, stage.id, pid]
          );
        } else {
          // Create new stage
          await pool.query(
            `INSERT INTO project_stages 
             (project_pid, stage_definition_id, assigned_tech_id, planned_duration_days)
             VALUES ($1, $2, $3, $4)`,
            [pid, stage.stage_definition_id, stage.assigned_tech_id || null, stage.planned_duration_days || 7]
          );
        }
      }

      // Recalculate dates
      await recalculateProjectStageDates(pid);
    }

    await pool.query('COMMIT');

    // Fetch complete updated project
    const completeProject = await pool.query(`
      SELECT 
        p.*,
        c.customer_name,
        COALESCE(
          JSON_AGG(
            JSON_BUILD_OBJECT(
              'id', ps.id,
              'stage_definition_id', ps.stage_definition_id,
              'stage_name', sd.display_name,
              'sort_order', sd.sort_order,
              'assigned_tech_id', ps.assigned_tech_id,
              'tech_name', u.display_name,
              'planned_start_date', ps.planned_start_date,
              'planned_end_date', ps.planned_end_date,
              'planned_duration_days', ps.planned_duration_days,
              'actual_start_date', ps.actual_start_date,
              'actual_end_date', ps.actual_end_date,
              'is_current', ps.is_current,
              'is_complete', ps.is_complete
            ) ORDER BY sd.sort_order
          ) FILTER (WHERE ps.id IS NOT NULL),
          '[]'
        ) as stages
      FROM projects p
      LEFT JOIN customers c ON p.customer_id = c.customer_id
      LEFT JOIN project_stages ps ON p.pid = ps.project_pid
      LEFT JOIN stage_definitions sd ON ps.stage_definition_id = sd.id
      LEFT JOIN users u ON ps.assigned_tech_id = u.id
      WHERE p.pid = $1
      GROUP BY p.pid, c.customer_name
    `, [pid]);

    return res.json(completeProject.rows[0]);

  } catch (err) {
    await pool.query('ROLLBACK');
    console.error('Error updating project:', err);
    return res.status(500).json({ error: 'Failed to update project' });
  }
});

// Delete project (Admin, Supervisor, Manager only)
app.delete(
  '/api/projects/:pid',
  requireRole('admin', 'supervisor', 'manager'),
  async (req, res) => {
    try {
      const { pid } = req.params;

      // Check if project exists
      const check = await pool.query('SELECT pid FROM projects WHERE pid = $1', [pid]);
      if (check.rows.length === 0) {
        return res.status(404).json({ error: 'Project not found' });
      }

      // Delete project (cascades to stages)
      await pool.query('DELETE FROM projects WHERE pid = $1', [pid]);

      return res.status(204).send();
    } catch (err) {
      console.error('Error deleting project:', err);
      return res.status(500).json({ error: 'Failed to delete project' });
    }
  }
);

// Get stage definitions
app.get('/api/stage-definitions', requireAuth, async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT * FROM stage_definitions
      ORDER BY sort_order
    `);
    
    res.json(result.rows);
  } catch (err) {
    console.error('Error fetching stage definitions:', err);
    res.status(500).json({ error: 'Failed to fetch stage definitions' });
  }
});

// Update stage definition (Admin only)
app.put('/api/stage-definitions/:id', requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { default_duration_days } = req.body;

    const result = await pool.query(
      `UPDATE stage_definitions
       SET default_duration_days = $1, updated_at = NOW()
       WHERE id = $2
       RETURNING *`,
      [default_duration_days, id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Stage definition not found' });
    }

    res.json(result.rows[0]);
  } catch (err) {
    console.error('Error updating stage definition:', err);
    res.status(500).json({ error: 'Failed to update stage definition' });
  }
});

// Update individual stage (Admin, Supervisor, Manager only)
app.put(
  '/api/projects/:pid/stages/:stageId',
  requireRole('admin', 'supervisor', 'manager'),
  async (req, res) => {
    try {
      const { pid, stageId } = req.params;
      const { assigned_tech_id, planned_duration_days, planned_start_date, planned_end_date } = req.body;

      await pool.query('BEGIN');

      const result = await pool.query(
        `UPDATE project_stages
         SET assigned_tech_id = $1,
             planned_duration_days = $2,
             planned_start_date = $3,
             planned_end_date = $4,
             updated_at = NOW()
         WHERE id = $5 AND project_pid = $6
         RETURNING *`,
        [assigned_tech_id || null, planned_duration_days || 7, planned_start_date, planned_end_date, stageId, pid]
      );

      if (result.rows.length === 0) {
        await pool.query('ROLLBACK');
        return res.status(404).json({ error: 'Stage not found' });
      }

      const user = getCurrentUser(req);

      // Log stage update
      await pool.query(
        `INSERT INTO audit_log (user_id, action, entity_type, entity_id, details)
         VALUES ($1, $2, $3, $4, $5)`,
        [
          user.id,
          'update',
          'project_stage',
          pid,
          JSON.stringify({
            stage_id: stageId,
            assigned_tech_id,
            planned_duration_days,
            updated_by: user.username
          })
        ]
      );

      // Recalculate dates for subsequent stages
      await recalculateProjectStageDates(pid);

      await pool.query('COMMIT');

      return res.json(result.rows[0]);
    } catch (err) {
      await pool.query('ROLLBACK');
      console.error('Error updating stage:', err);
      return res.status(500).json({ error: 'Failed to update stage' });
    }
  }
);

// Mark stage as complete/incomplete (All authenticated users)
app.patch(
  '/api/projects/:pid/stages/:stageId/complete',
  requireAuth,
  async (req, res) => {
    try {
      const { pid, stageId } = req.params;
      const { is_complete } = req.body;
      const user = getCurrentUser(req);

      await pool.query('BEGIN');

      const result = await pool.query(
        `UPDATE project_stages
         SET is_complete = $1,
             actual_end_date = CASE WHEN $1 = true THEN CURRENT_DATE ELSE actual_end_date END,
             updated_at = NOW()
         WHERE id = $2 AND project_pid = $3
         RETURNING *`,
        [is_complete, stageId, pid]
      );

      if (result.rows.length === 0) {
        await pool.query('ROLLBACK');
        return res.status(404).json({ error: 'Stage not found' });
      }

      // Log to audit
      await pool.query(
        `INSERT INTO audit_log (user_id, action, entity_type, entity_id, details)
         VALUES ($1, $2, $3, $4, $5)`,
        [
          user.id,
          'update',
          'project_stage_complete',
          pid,
          JSON.stringify({
            stage_id: stageId,
            is_complete,
            updated_by: user.username
          })
        ]
      );

      await pool.query('COMMIT');

      return res.json(result.rows[0]);
    } catch (err) {
      await pool.query('ROLLBACK');
      console.error('Error updating stage completion:', err);
      return res.status(500).json({ error: 'Failed to update stage' });
    }
  }
);

// Set stage as current (Admin, Supervisor, Manager only)
app.patch(
  '/api/projects/:pid/stages/:stageId/set-current',
  requireRole('admin', 'supervisor', 'manager'),
  async (req, res) => {
    try {
      const { pid, stageId } = req.params;

      await pool.query('BEGIN');

      // Set all stages for this project to not current
      await pool.query(
        'UPDATE project_stages SET is_current = false WHERE project_pid = $1',
        [pid]
      );

      // Set this stage to current
      const result = await pool.query(
        `UPDATE project_stages
         SET is_current = true, updated_at = NOW()
         WHERE id = $1 AND project_pid = $2
         RETURNING *`,
        [stageId, pid]
      );

      if (result.rows.length === 0) {
        await pool.query('ROLLBACK');
        return res.status(404).json({ error: 'Stage not found' });
      }

      await pool.query('COMMIT');

      return res.json(result.rows[0]);
    } catch (err) {
      await pool.query('ROLLBACK');
      console.error('Error setting current stage:', err);
      return res.status(500).json({ error: 'Failed to set current stage' });
    }
  }
);

// Delete stage (Admin, Supervisor, Manager only)
app.delete(
  '/api/projects/:pid/stages/:stageId',
  requireRole('admin', 'supervisor', 'manager'),
  async (req, res) => {
    try {
      const { pid, stageId } = req.params;

      const result = await pool.query(
        'DELETE FROM project_stages WHERE id = $1 AND project_pid = $2',
        [stageId, pid]
      );

      if (result.rowCount === 0) {
        return res.status(404).json({ error: 'Stage not found' });
      }

      return res.status(204).send();
    } catch (err) {
      console.error('Error deleting stage:', err);
      return res.status(500).json({ error: 'Failed to delete stage' });
    }
  }
);

// -----------------------------------------------------------------------------
// WEEKLY SCHEDULE (CSV) API
// -----------------------------------------------------------------------------

app.post('/weekly-grind/api/save', async (req, res) => {
  try {
    const { mondayISO, csv } = req.body;

    if (!mondayISO || !csv) {
      return res.status(400).json({ error: 'mondayISO and csv are required' });
    }

    const existingSchedule = await pool.query(
      'SELECT id FROM week_schedules WHERE week_start = $1',
      [mondayISO]
    );

    if (existingSchedule.rows.length > 0) {
      await pool.query(
        'UPDATE week_schedules SET csv_data = $1, updated_at = NOW() WHERE week_start = $2',
        [csv, mondayISO]
      );
    } else {
      await pool.query(
        'INSERT INTO week_schedules (week_start, csv_data) VALUES ($1, $2)',
        [mondayISO, csv]
      );
    }

    return res.json({ success: true });
  } catch (err) {
    console.error('Error saving week schedule:', err);
    return res.status(500).json({ error: 'Failed to save schedule' });
  }
});

app.get('/weekly-grind/cantina-schedule-:mondayISO.csv', async (req, res) => {
  try {
    const { mondayISO } = req.params;

    const result = await pool.query(
      'SELECT csv_data FROM week_schedules WHERE week_start = $1',
      [mondayISO]
    );

    if (result.rows.length === 0) {
      const defaultCSV = 'week_start,tech,day,slot,type,details,notes,status\n';
      return res.type('text/csv').send(defaultCSV);
    }

    return res.type('text/csv').send(result.rows[0].csv_data);
  } catch (err) {
    console.error('Error fetching week schedule:', err);
    return res.status(500).send('week_start,tech,day,slot,type,details,notes,status\n');
  }
});

// -----------------------------------------------------------------------------
// STATIC FILE SERVING & PAGE ROUTES
// -----------------------------------------------------------------------------

const PUB_DIR = path.join(__dirname, 'public');
const WG_DIR = path.join(PUB_DIR, 'weekly-grind');

// Login page
app.get(['/weekly-grind/login', '/weekly-grind/login/'], (_req, res) => {
  res.sendFile(path.join(WG_DIR, 'login.html'));
});

// Profile page
app.get(['/weekly-grind/profile', '/weekly-grind/profile/'], (_req, res) => {
  res.sendFile(path.join(WG_DIR, 'profile.html'));
});

// Admin page
app.get(['/weekly-grind/admin', '/weekly-grind/admin/'], (_req, res) => {
  res.sendFile(path.join(WG_DIR, 'cantina_admin.html'));
});

// Time Frames Admin page
app.get(['/weekly-grind/admin/timeframes', '/weekly-grind/admin/timeframes/'], (_req, res) => {
  res.sendFile(path.join(WG_DIR, 'admin-timeframes.html'));
});

// Stage Time Frames Admin Page

// ============================================================================
// MAIN PAGE ROUTES
// ============================================================================

// Main schedule view
app.get('/weekly-grind/view', requireAuth, (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'weekly-grind', 'cantina_view.html'));
});

// Projects list
app.get('/weekly-grind/projects', requireAuth, (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'weekly-grind', 'cantina_projects.html'));
});

// New project form
app.get('/weekly-grind/projects/new', requireRole('coordinator', 'supervisor', 'manager'), (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'weekly-grind', 'cantina_projects_new.html'));
});

// Repair & Reimage tracking
app.get('/weekly-grind/repair-reimage', requireAuth, (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'weekly-grind', 'repair-reimage.html'));
});

// Scheduling page
app.get('/weekly-grind/scheduling', requireRole('supervisor', 'manager', 'coordinator'), (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'weekly-grind', 'cantina_scheduling.html'));
});

// Admin/Scheduling alias (for backwards compatibility)
app.get('/weekly-grind/admin', requireRole('supervisor', 'manager', 'coordinator'), (req, res) => {
  res.redirect('/weekly-grind/scheduling');
});

// Supervisor Dashboard
app.get('/weekly-grind/supervisor-dashboard', requireRole('supervisor'), (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'weekly-grind', 'supervisor-dashboard.html'));
});

// Manager Dashboard
app.get('/weekly-grind/manager-dashboard', requireRole('manager'), (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'weekly-grind', 'manager-dashboard.html'));
});

// Admin Options
app.get('/weekly-grind/admin-options', requireAdmin, (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'weekly-grind', 'admin-options.html'));
});

// Users & Roles
app.get('/weekly-grind/users', requireAdmin, (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'weekly-grind', 'weekly-grind-users.html'));
});

app.get('/weekly-grind/admin/stage-timeframes', (_req, res) => {
  res.sendFile(path.join(WG_DIR, 'admin-timeframes.html'));
});

// View page
app.get(['/weekly-grind/view', '/weekly-grind/view/'], (_req, res) => {
  res.sendFile(path.join(WG_DIR, 'cantina_view.html'));
});

// Projects page
app.get(['/weekly-grind/projects', '/weekly-grind/projects/'], (_req, res) => {
  res.sendFile(path.join(WG_DIR, 'cantina_projects.html'));
});

// New Project page
app.get(['/weekly-grind/projects/new', '/weekly-grind/projects/new/'], (_req, res) => {
  res.sendFile(path.join(WG_DIR, 'cantina_projects_new.html'));
});

// Edit Project page
app.get('/weekly-grind/projects/:pid/edit', (_req, res) => {
  res.sendFile(path.join(WG_DIR, 'cantina_projects_edit.html'));
});

// Users & Roles page
app.get(['/weekly-grind/users', '/weekly-grind/users/'], (_req, res) => {
  res.sendFile(path.join(WG_DIR, 'weekly-grind-users.html'));
});

// Initiatives page (Under Construction)
app.get(['/weekly-grind/initiatives', '/weekly-grind/initiatives/'], (_req, res) => {
  res.sendFile(path.join(WG_DIR, 'cantina_initiatives.html'));
});

// Weekly Grind root redirect
app.get(['/weekly-grind', '/weekly-grind/'], (req, res) => {
  // Check if user is logged in
  const user = getCurrentUser(req);
  if (!user) {
    // Not logged in, send to login page
    return res.redirect('/weekly-grind/login');
  }
  
  // Logged in, redirect based on role
  if (user.role === 'tech') return res.redirect('/weekly-grind/view');
  if (user.role === 'coordinator') return res.redirect('/weekly-grind/projects');
  if (user.role === 'supervisor') return res.redirect('/weekly-grind/supervisor-dashboard');
  if (user.role === 'manager') return res.redirect('/weekly-grind/manager-dashboard');
  if (user.is_admin) return res.redirect('/weekly-grind/admin-options');
  
  // Default
  return res.redirect('/weekly-grind/view');
});

// Root redirect
app.get('/', (req, res) => {
  const user = getCurrentUser(req);
  if (!user) {
    return res.redirect('/weekly-grind/login');
  }
  res.redirect('/weekly-grind/view');
});

// Health endpoint
app.get('/health', (_req, res) => res.json({ ok: true }));

// Auth check endpoint (for frontend)
app.get('/weekly-grind/api/auth-check', (_req, res) =>
  res.json({ authenticated: true, stubMode: true })
);

// Static assets (must come after dynamic routes)
app.use(express.static(PUB_DIR, { index: false, maxAge: '1h', etag: true }));

// -----------------------------------------------------------------------------
// START SERVER
// -----------------------------------------------------------------------------

(async () => {
  try {
    await testDbConnection();
    app.listen(PORT, () => {
      console.log(`Server listening on port ${PORT}`);
      console.log(`Visit: http://localhost:${PORT}/weekly-grind/admin`);
    });
  } catch (err) {
    console.error('Failed to start server:', err);
    process.exit(1);
  }
})();
