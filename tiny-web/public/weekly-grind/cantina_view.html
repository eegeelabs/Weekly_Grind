<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Weekly Grind View</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
:root {
  --bg: #0f1520;
  --panel: #111827;
  --text: #e5e7eb;
  --muted: #9ca3af;
  --line: #1f2937;
  --ok: #10b981;
}
html, body { height:100%; }
body { background: var(--bg); color: var(--text); margin:0; font:14px system-ui, -apple-system, Segoe UI, Arial; }
header {
  background: var(--panel);
  padding:10px;
  border-bottom:1px solid var(--line);
  position:sticky;
  top:0;
  z-index:10;
  display:flex;
  gap:6px;
  align-items:center;
  justify-content:space-between;
}
header small { color:var(--muted); }

/* Collapsible tech blocks */
.tech-block { border-bottom:1px solid var(--line); }
.tech-head { display:flex; justify-content:space-between; padding:10px; cursor:pointer; background:#0b1322; }
.tech-head:hover { background:#121c2c; }
.tech-head .name { font-weight:600; }
.tech-body { display:block; padding:10px; }

/* Day grid */
.day-row { display:grid; grid-template-columns: repeat(5, 1fr); gap:8px; margin-bottom:12px; }
.day-cell { background:#111827; border:1px solid var(--line); padding:8px; border-radius:6px; }
.day-title { font-weight:600; margin-bottom:6px; display:flex; justify-content:space-between; }
.day-title small { color:var(--muted); }

/* Tasks */
.task {
  border-radius:4px;
  padding:2px 6px;
  display:grid;
  grid-template-columns: 1fr auto; /* left: tag + details, right: checkbox */
  align-items:center;
  gap:8px;
  margin-bottom:4px;
}
.task.done { opacity:0.4; }

/* Type color tags */
.type-tag { font-weight:600; padding:1px 4px; border-radius:4px; font-size:12px; margin-right:6px; }
.type-IMG{background:#2563eb33;color:#60a5fa;}
.type-Testing{background:#7c3aed33;color:#c4b5fd;}
.type-Deploy{background:#05966933;color:#6ee7b7;}
.type-PC-O{background:#d9770633;color:#fcd34d;}
.type-R\/R{background:#dc262633;color:#fca5a5;}
.type-Other{background:#6b728033;color:#d1d5db;}

.notes { margin-top:6px; font-size:13px; color:var(--muted); white-space:pre-line; }

.hint { color:var(--muted); font-size:12px; margin-left:10px; }
.hint.ok { color:var(--ok); }
</style>
</head>
<body>
<header>
  <strong>Weekly Grind</strong>
  <span>
    Week: <input id="week" type="date">
    <span id="updated" class="hint"></span>
    <span id="hint" class="hint"></span>
  </span>
</header>
<div id="content"></div>

<script>
const content = document.getElementById('content');
const week    = document.getElementById('week');
const hint    = document.getElementById('hint');
const updated = document.getElementById('updated');

const pad2=n=>String(n).padStart(2,'0');
const toISO=d=>`${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
function mondayOf(iso){ const d=new Date(`${iso}T00:00:00`); const w=d.getDay(); d.setDate(d.getDate()+(w===0?-6:1-w)); return toISO(d); }

/* CSV helpers */
function parseCSV(text){
  let rows=[],i=0,field='',inQ=false,row=[];
  const push=()=>{row.push(field);field='';};
  const end =()=>{rows.push(row);row=[];};
  while(i<text.length){
    const ch=text[i++];
    if(inQ){
      if(ch=='"'){ if(text[i]=='"'){ field+='"'; i++; } else inQ=false; }
      else field+=ch;
    }else{
      if(ch=='"') inQ=true;
      else if(ch==',') push();
      else if(ch=='\n'){ push(); end(); }
      else if(ch!='\r') field+=ch;
    }
  }
  if(field.length||row.length){ push(); end(); }
  return rows;
}
function csvEscape(v){ if(v==null)v=''; let s=String(v); if(/[",\n]/.test(s)) s='"'+s.replace(/"/g,'""')+'"'; return s; }
function toCSV(rows){ return rows.map(r=>r.map(csvEscape).join(',')).join('\n')+'\n'; }
function normalize(rows){
  const head=rows[0]||[];
  const idx={}; ['week_start','tech','day','slot','type','details','notes','status'].forEach(k=>idx[k]=head.indexOf(k));
  const out=[];
  for(let i=1;i<rows.length;i++){
    const r=rows[i]; if(!r||!r.length) continue;
    out.push({ week_start:r[idx.week_start]||'', tech:r[idx.tech]||'', day:r[idx.day]||'',
               slot:r[idx.slot]||'', type:r[idx.type]||'', details:r[idx.details]||'',
               notes:r[idx.notes]||'', status:r[idx.status]||'' });
  }
  return out;
}
function denormalize(rows){
  const head=['week_start','tech','day','slot','type','details','notes','status'];
  const body = rows.map(r=>[r.week_start,r.tech,r.day,r.slot,r.type,r.details,r.notes,r.status]);
  return [head, ...body];
}

function dayLabels(mon){
  const d=new Date(`${mon}T00:00:00`); const names=['Mon','Tue','Wed','Thu','Fri']; const out=[];
  for(let i=0;i<5;i++){ const dd=new Date(d); dd.setDate(d.getDate()+i);
    out.push({ iso:toISO(dd), label:names[i], md:toISO(dd).slice(5).replace('-','/') });
  }
  return out;
}

/* Load + render */
async function load(mon){
  hint.textContent = '';
  const resp = await fetch(`/weekly-grind/cantina-schedule-${mon}.csv`, {cache:'no-store'});
  const rows = normalize(parseCSV(await resp.text()));
  const techs=[...new Set(rows.map(r=>r.tech).filter(Boolean))].sort();
  const DAYS=dayLabels(mon);
  content.innerHTML='';

  techs.forEach(t=>{
    const block=document.createElement('div'); block.className='tech-block';
    const head =document.createElement('div'); head.className='tech-head'; head.innerHTML=`<span class="name">${t}</span>`;
    const body =document.createElement('div'); body.className='tech-body';
    const dayRow=document.createElement('div'); dayRow.className='day-row';

    DAYS.forEach(d=>{
      const cell=document.createElement('div'); cell.className='day-cell';
      cell.innerHTML=`<div class="day-title">${d.label} <small>${d.md}</small></div>`;
      const r1=rows.find(r=>r.tech===t&&r.day===d.iso&&r.slot=='1');
      const r2=rows.find(r=>r.tech===t&&r.day===d.iso&&r.slot=='2');

      [ ['1',r1], ['2',r2] ].forEach(([slot,r])=>{
        if(!r) return;
        const done=/^(y|1|true)$/i.test(r.status||'');
        const div=document.createElement('div'); div.className='task'+(done?' done':'');
        div.innerHTML = `
          <div>
            <span class="type-tag type-${(r.type||'Other').replace(/[^A-Za-z0-9]/g,'_')}">${r.type||''}</span>
            <span>${r.details||''}</span>
          </div>
          <input type="checkbox"
                 class="done-toggle"
                 data-tech="${t}"
                 data-day="${d.iso}"
                 data-slot="${slot}"
                 ${done?'checked':''}
          >`;
        cell.appendChild(div);
      });

      const notes=(r1&&r1.notes)||(r2&&r2.notes)||'';
      if(notes) cell.innerHTML += `<div class="notes">${notes}</div>`;

      dayRow.appendChild(cell);
    });

    body.appendChild(dayRow);
    block.appendChild(head); block.appendChild(body);
    head.onclick = () => { body.style.display = body.style.display==='block' ? 'none':'block'; };
    content.appendChild(block);
  });

  // update last-modified
  try{
    const headResp = await fetch(`/weekly-grind/cantina-schedule-${mon}.csv`, { method:'HEAD' });
    const lm = headResp.headers.get('last-modified');
    if(lm) updated.textContent = `Last updated: ${new Date(lm).toLocaleString()}`;
  }catch{}
}

/* Inline save: toggle a single status and persist the CSV */
async function saveToggle(mon, tech, day, slot, isDone){
  try{
    hint.classList.remove('ok');
    hint.textContent='Saving…';

    // 1) Pull latest CSV
    const r = await fetch(`/weekly-grind/cantina-schedule-${mon}.csv`, {cache:'no-store'});
    const rows = parseCSV(await r.text());
    const head = rows[0] || [];
    const idx = {};
    ['week_start','tech','day','slot','type','details','notes','status'].forEach(k=>idx[k]=head.indexOf(k));

    // 2) Find target row; if missing, create a minimal row
    let found = false;
    for(let i=1;i<rows.length;i++){
      const rr = rows[i];
      if(rr[idx.tech]===tech && rr[idx.day]===day && rr[idx.slot]===slot){
        rr[idx.status] = isDone ? 'Y' : '';
        found = true; break;
      }
    }
    if(!found){
      const newRow = new Array(head.length).fill('');
      newRow[idx.week_start] = mon;
      newRow[idx.tech]       = tech;
      newRow[idx.day]        = day;
      newRow[idx.slot]       = slot;
      newRow[idx.status]     = isDone ? 'Y' : '';
      rows.push(newRow);
    }

    // 3) Post back via existing Admin save endpoint
    const csvText = rows.map(r=>r.map(csvEscape).join(',')).join('\n')+'\n';
    const resp = await fetch('/weekly-grind/api/save', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ mondayISO: mon, csv: csvText })
    });

    if(!resp.ok) throw new Error('Save failed');

    hint.textContent='Saved';
    hint.classList.add('ok');

    // refresh the "last updated" timestamp
    try{
      const headResp = await fetch(`/weekly-grind/cantina-schedule-${mon}.csv`, { method:'HEAD' });
      const lm = headResp.headers.get('last-modified');
      if(lm) updated.textContent = `Last updated: ${new Date(lm).toLocaleString()}`;
    }catch{}

  }catch(e){
    hint.textContent='Save failed';
    console.error(e);
    // Let UI stay as-is; user can re-toggle if needed
  }finally{
    setTimeout(()=>{ hint.textContent=''; hint.classList.remove('ok'); }, 1200);
  }
}

/* Delegated handler for done checkboxes */
content.addEventListener('change', (ev)=>{
  const el = ev.target;
  if(!el.classList.contains('done-toggle')) return;
  const mon  = week.value;
  const tech = el.dataset.tech;
  const day  = el.dataset.day;
  const slot = el.dataset.slot;
  const isDone = el.checked;

  // fade/unfade immediately (optimistic)
  const taskDiv = el.closest('.task');
  if(taskDiv) taskDiv.classList.toggle('done', isDone);

  saveToggle(mon, tech, day, slot, isDone);
});

/* boot */
const todayISO = toISO(new Date());
const monISO   = mondayOf(todayISO);
week.value = monISO;
week.addEventListener('change', e=>load(e.target.value));
load(monISO);
</script>
</body>
</html>
